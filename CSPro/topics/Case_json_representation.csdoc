﻿<title>JSON Representation: Case</title>

Case data can be output in JSON format. This outputs the data as an array of objects. Each object represents a single case.

<link JSONCaseData.html>Action Invoker</link>

The base of the case object is the root. This always contains the following items:
<list>
<li>    <arg>key</arg>, a string containing the case key </li>
<li>    <arg>uuid</arg>, a string containing the case uuid </li>
</list>

The root will contain the following items only if Verbose is specified for the output pff:
<list>
<li>    <arg>label</arg>, a string containing the label</li>
<li>    <arg>deleted</arg>, a boolean containing whether the case is deleted </li>
<li>    <arg>verified</arg>, a boolean containing whether the case is verified </li>
</list>

The root will contain the following items only if Verbose is specified, or occurrences are present:
<list>
<li>    <arg>partialSave</arg>, null if the case not partial, or an object if the case is partial. This object contains the following items: </li>
<indent><li><arg>mode</arg>, a string containing saved mode (add, modify, etc)</li></indent>
<indent><li><arg>name</arg>, a string containing the name of the partial save's location</li></indent>
<indent><li><arg>levelKey</arg>, a string containing the level key (if verbose)</li></indent>
<indent><li><arg>occurrences</arg>, an array containing all occurrences by <arg>record</arg>, <arg>item</arg>, and <arg>subitem</arg> location
</li></indent>
<li>    <arg>notes</arg>, an empty array if the case is verbose and has no notes, or an array of note objects. Each note object in the array contains the following: </li>
<indent><li><arg>text</arg>, a string containing the text of the note</li></indent>
<indent><li><arg>modifiedTime</arg>, a string containing the time the note was modified</li></indent>
<indent><li><arg>operatorId</arg>, a string containing the ID of the operator who made the note</li></indent>
<indent><li><arg>name</arg>, a string containing the name of where the note was made</li></indent>
<indent><li><arg>levelKey</arg>, a string containing the level key (if verbose)</li></indent>
<indent><li><arg>occurrences</arg>, an array containing all occurrences by <arg>record</arg>, <arg>item</arg>, and <arg>subitem</arg> location</li></indent>
</list>

Then the Case Data will be listed, following a heirarchy based on the Dictionary. The <arg>first level</arg> of the dictionary is an object containing all <arg>ID items</arg> for that level, all <arg>records</arg> listed in that level, and the <arg>second level</arg> directly below it in the dictionary if there is one.

<arg>Records</arg> are arrays. They contain objects for each occurrence of data they have. They only contain non-ID <arg>items</arg>.

Repeating items are arrays containing all instances of an item.

<arg>Items</arg> are objects. Alphanumeric tems contain a <arg>code</arg> with their value, which can be a string or a numeric. If the item has no value, no code will be listed and it will be an empty object. If the "writeLabels=true" connection string attribute is specified, the Item will contain the value's string <arg>label</arg> as well. File objects (such as Images, Audios, Documents, and Geometries) do not contain a code or label like alpha/numeric items. Instead they contain a string <arg>signature</arg> and object <arg>metadata</arg>. The <arg>metadata</arg> object contains the string <arg>filename</arg> for the file name of the file and the string <arg>mime</arg> for the file type.


JSON Example:
<color JSON>
[
{
  "key": "1",
  "uuid": "b5512c5f-8acd-4df7-b5d5-e7dbff10ad00",
  "label": "",
  "deleted": false,
  "verified": false,
  "partialSave": null,
  "notes": [],
  "BINARY_DICT_LEVEL": {
    "BINARY_DICT_ID": {
      "code": 1
    },
    "BINARY_DICT_REC": [
      {
        "VALUE": {
          "code": 2
        },
        "MY_IMAGE": {
          "metadata": {
            "filename": "1705030747953827.jpg",
            "mime": "image/jpeg"
          },
          "signature": "76e63fa382854ec202232eb975bbd29a"
        },
        "STRING_VALUE": {
          "code": "greg"
        }
      }
    ],
    "REPEATING_REC": [],
    "SINGLE_NOT_REQUIRED_REC": [
      {
        "SINGLE_NOT_REQUIRED_VALUE": {},
        "REPEATING_IMAGE": [],
        "IMAGE_ON_NOT_REQUIRED_REC": {}
      }
    ],
    "REPEATING_SING_ITEMS_REC": [
      {
        "ITEM_1": {},
        "ITEM_2": {},
        "ITEM_DOC": {}
      }
    ],
    "SECOND_LEVEL": [
      {
        "L2ID": {
          "code": 1
        },
        "NEW_RECORD": [
          {
            "L2_NUMERIC": {
              "code": 1
            },
            "L2_BINARY": {},
            "L2_STRING": {
              "code": "l2"
            }
          }
        ]
      },
      {
        "L2ID": {
          "code": 2
        },
        "NEW_RECORD": [
          {
            "L2_NUMERIC": {
              "code": 2
            },
            "L2_BINARY": {},
            "L2_STRING": {
              "code": "l2"
            }
          }
        ]
      }
    ]
  }
}
]
</color>

Multiple-level dictionaries (advanced)

If there are multiple levels in the dictionary, the 2nd level will be an array of objects contained within the 1st level. Each object in the array is a different occurrence of data at that level. If there is a 3rd level, it will be an array of objects contained within each of the 2nd level objects.

Levels (other than the topmost level) are arrays. If there are no occurrences of that level, the array will be empty. If there were occurrences, each occurrence will be listed as an object in that array. Each occurrence in a level is composed of the ID items, followed by the Records, followed by the level directly below it in the dictionary if there is one.
