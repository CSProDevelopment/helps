<title>Array Statement</title>

The two formats are identical except in the handling of assigning values to the array dimensions. In Format 1, all dimension values would be listed out. In Format 2, the special symbol "..." can be written at the end of the array declaration when providing start values for the array dimensions. The "..." signifies that all subsequent array dimensions will be assigned the values given up to that point. Note that if the "..." symbol is used for assignment, all values must be separated by commas (if it isn't used, the values can just be listed separated by spaces). See Example 4 below for further clarification.

<subheader>Format 1</subheader>

<logicsyntax>
array 『<arg>array_type</arg>』 <arg>array_name</arg>(<arg>dim1</arg>『, ..., <arg>dimN</arg>』) 『save』 『= <arg>dim1_value</arg>『, ..., <arg>dimN_value</arg>』』;
</logicsyntax>

<subheader>Format 2</subheader>

<logicsyntax>
array 『<arg>array_type</arg>』 <arg>array_name</arg>(<arg>dim1</arg>『, ..., <arg>dimN</arg>』) 『save』 『= <arg>dim1_value</arg>『, <arg>dim2_value</arg>『, ...』』;
</logicsyntax>


<subheader>Description</subheader>

The <logiccolor>array</logiccolor> statement creates an <link array.hgt>array</link> with the name <arg>array_name</arg>. Only one array at a time can be declared with the array statement. The array name must be unique and must contain only letters, numbers, or the underscore character. The name must begin with a letter. You can declare arrays in <logiccolor>PROC GLOBAL</logiccolor> or locally in functions or procedures.

Arrays can be numeric, alphanumeric, or string. By default an array is numeric, but the type can be modified by specifying the <arg>array_type</arg>.  If creating an alphanumeric array, the length of each array element can be specified by definining the <arg>array_type</arg> as follows:

<logicsyntax>alpha 『(<arg>array_length</arg>)』</logicsyntax>

If <arg>array_length</arg> is not specified, each element will be 16 characters.

<b>Array Size:</b> The size of each dimension is specified by supplying a constant positive numeric value, <arg>dimension1</arg> to <arg>dimensionN</arg>. An array must have at least one dimension. The starting position of each dimension is 1, not 0. CSPro supports arrays of an unlimited number of dimensions. A previously-defined numeric value can also be used to specify the dimension size. The <logiccolor>array.length</logiccolor> function can be used to query the size of a dimension.

<b>Initializing Arrays:</b> The initial values of the array elements can be set when declaring the array by listing each value, separated by a comma or blank. If some values are defined followed by <b>...</b>, the values that have been defined to that point will be used over and over until the entire array has been initialized. However in this situation a comma <b>must</b> be used to separate the values (see Example 4 below).

<b>Array Start Values:</b> With a numeric array, each element starts with the value 0. For alphanumeric and string arrays, each element starts as a blank string. If using a numeric <link initialize_hot_decks_using_saved_arrays.hgt>saved array</link>, the initial array contents are <logiccolor>default</logiccolor>.

<subheader>Saved Arrays</subheader>

The optional keyword <logiccolor>save</logiccolor> indicates that the array values should be saved to a file and loaded from that file when the program is run again. This allows you to maintain the values of the arrays across multiple runs of the same program. When one or more arrays in the program are marked with <logiccolor>save</logiccolor>, the first time the application is run, a <link saved_arrays_file_sva.hgt>saved array file</link> is created and the values of the arrays are written to the file at the end of program execution. On consecutive runs of the program, the initial values of the arrays are read in from the file. This is particularly useful for setting the initial values of hot decks. In this scenario, the program is run twice. The first run fills the hot deck and saves the hot deck array to the file. The second run loads the values saved from the first run and uses them as the initial values for the hot deck for imputation. See <topic initialize_hot_decks_in_program_logic.hgt /> for more information.

All arrays marked with <logiccolor>save</logiccolor> in the application are written to the same file. By default this file has the same name as the application but with a .sva file extension appended to it (for example, MyApplication.bch.sva). You can modify the name of the saved array file by using the PFF <pffcolor>SaveArray</pffcolor> attribute.


<subheader>Example 1 (Numeric)</subheader>

<logic>
PROC GLOBAL

array numeric MinAgeMarriage(2) save = 15, // male
									   12; // female

PROC MARRIAGE_AGE

	if MARRIAGE_AGE < MinAgeMarriage(SEX) then
		errmsg("The minimum age of marriage is %d", MinAgeMarriage(SEX));
		reenter;
	endif;
</logic>


<subheader>Example 2 (String)</subheader>

<logic>
PROC GLOBAL

array string Months(12) = "Jan", "Feb", "Mar", "Apr", "May", "Jun",
						  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec";

function string FormatDate()
	FormatDate = maketext("%d %s %d", sysdate("DD"), Months(sysdate("MM")), sysdate("YYYY"));
end;
</logic>

<subheader>Example 3 (Assignment)</subheader>

<logic>
PROC GLOBAL

numeric NumberProvinces = 12;
array SexCountsByProvince(NumberProvinces, 2); // province by sex

PROC SEX

	inc(SexCountsByProvince(PROVINCE, SEX));

PROC DISPLAY_COUNTS

	do numeric counter = 1 while counter <= SexCountsByProvince.length(1)
		errmsg("Province %d has %d males and %d females", counter,
			SexCountsByProvince(counter, 1), SexCountsByProvince(counter, 2));
	enddo;
</logic>

<subheader>Example 4 (Repeating Assignment with "...")</subheader>

When hardcoding all hot deck dimension start values, a space can be used as a separator between values. However, when the ellipse (...) is used to repeat previously-given values, all values must be comma-delimited.

<logic>
PROC GLOBAL

// relationship codes correspond to:
//   1=head
//   2=spouse
//   3=child
//   4=grandchild
//   5=parent of head
//   6=sibling of head
//   7=other relative
//   8=unrelated

array HD_Sex_Relationship (8) = 1 2 1 1 2 2 1 2;	// this WILL     compile, all values are given
array HD_Sex_Relationship (8) = 1 2 1 1 ...;		// this will NOT compile, missing comma separators
array HD_Sex_Relationship (8) = 1, 2, 1, 1, ...;	// this WILL     compile, each value is separated by a comma

</logic>

<seealso array.hgt hashmap.hgt list.hgt numeric_statement.hgt alpha_statement.hgt string_statement.hgt saved_arrays_file_sva.hgt />
